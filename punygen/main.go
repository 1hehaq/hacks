package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"strings"

	"golang.org/x/net/idna"
)

var homoglyphs = map[rune][]rune{
	'a': {'à', 'á', 'â', 'ã', 'ä', 'å', 'ɑ', 'А', 'Α', 'Ꭺ', 'Ａ', '𝔄', '𝕬', '𝒜', '𝐀', '𝐴', '𝘈', '𝙰', '𝖠', '𝗔', '𝘼', '𝚨', '𝑨', 'ⓐ', 'Ⓐ', '🅐', '🅰', '𝔞', '𝖆', '𝒶', '𝗮', '𝘢', 'ā', 'ă', 'ą', 'ȃ', 'ȧ', 'ạ', 'ả', 'ấ', 'ầ', 'ẩ', 'ẫ', 'ậ', 'ắ', 'ằ', 'ẳ', 'ẵ', 'ặ'},
	'b': {'Ь', 'Ꮟ', 'Ƅ', 'ᖯ', '𝐛', '𝑏', '𝒃', '𝓫', '𝔟', '𝕓', '𝖇', '𝗯', '𝘣', '𝙗', '𝚋', 'ƀ', 'ɓ', 'ḃ', 'ḅ', 'ḇ', 'Ḃ', 'Ḅ', 'Ḇ', 'Ɓ', 'Ƃ', 'ƃ'},
	'c': {'ϲ', 'с', 'ƈ', 'ȼ', 'ḉ', 'ⲥ', '𝐜', '𝑐', '𝒄', '𝓬', '𝔠', '𝕔', '𝖈', '𝗰', '𝘤', '𝙘', '𝚌', 'ć', 'ĉ', 'ċ', 'č', 'ç', 'ḉ', 'ć', 'Ć', 'Ĉ', 'Ċ', 'Č', 'Ç', 'Ḉ', 'Ȼ'},
	'd': {'ԁ', 'ժ', 'Ꮷ', '𝐝', '𝑑', '𝒅', '𝓭', '𝔡', '𝕕', '𝖉', '𝗱', '𝘥', '𝙙', '𝚍', 'ď', 'đ', 'ḋ', 'ḍ', 'ḏ', 'ḑ', 'ḓ', 'Ď', 'Đ', 'Ḋ', 'Ḍ', 'Ḏ', 'Ḑ', 'Ḓ', 'ƌ', 'ɖ', 'ɗ'},
	'e': {'е', 'ҽ', '℮', 'ḛ', 'ḝ', 'ẹ', 'é', 'è', 'ê', 'ë', 'ē', 'ė', 'ę', '𝐞', '𝑒', '𝒆', '𝓮', '𝔢', '𝕖', '𝖊', '𝗲', '𝘦', '𝙚', '𝚎', 'ĕ', 'ę', 'ė', 'ě', 'ȅ', 'ȇ', 'ȩ', 'ḕ', 'ḗ', 'ḙ', 'ḛ', 'ḝ', 'ẽ', 'ẻ', 'ế', 'ề', 'ể', 'ễ', 'ệ'},
	'f': {'ғ', '𝐟', '𝑓', '𝒇', '𝓯', '𝔣', '𝕗', '𝖋', '𝗳', '𝘧', '𝙛', '𝚏', 'ḟ', 'Ḟ', 'ƒ', 'Ƒ', 'ꜰ'},
	'g': {'ɡ', 'ց', '𝐠', '𝑔', '𝒈', '𝓰', '𝔤', '𝕘', '𝖌', '𝗴', '𝘨', '𝙜', '𝚐', 'ĝ', 'ğ', 'ġ', 'ģ', 'ǧ', 'ǵ', 'ḡ', 'Ĝ', 'Ğ', 'Ġ', 'Ģ', 'Ǧ', 'Ǵ', 'Ḡ', 'ƍ', 'ɠ'},
	'h': {'һ', 'հ', 'Ꮒ', 'ℎ', '𝐡', '𝒉', '𝒽', '𝓱', '𝔥', '𝕙', '𝖍', '𝗵', '𝘩', '𝙝', '𝚑', 'ĥ', 'ħ', 'ȟ', 'ḣ', 'ḥ', 'ḧ', 'ḩ', 'ḫ', 'Ĥ', 'Ħ', 'Ȟ', 'Ḣ', 'Ḥ', 'Ḧ', 'Ḩ', 'Ḫ', 'ƕ'},
	'i': {'і', 'ɩ', 'Ꭵ', 'Ⅰ', 'ı', 'í', 'ì', 'î', 'ï', 'ī', 'į', '𝐢', '𝑖', '𝒊', '𝓲', '𝔦', '𝕚', '𝖎', '𝗶', '𝘪', '𝙞', '𝚒', 'ĩ', 'ĭ', 'į', 'ı', 'ǐ', 'ȉ', 'ȋ', 'ḭ', 'ḯ', 'ỉ', 'ị', 'İ', 'Ì', 'Í', 'Î', 'Ï', 'Ĩ', 'Ī', 'Ĭ', 'Į', 'Ǐ', 'Ȉ', 'Ȋ', 'Ḭ', 'Ḯ', 'Ỉ', 'Ị'},
	'j': {'ј', 'ʝ', 'ϳ', '𝐣', '𝑗', '𝒋', '𝓳', '𝔧', '𝕛', '𝖏', '𝗷', '𝘫', '𝙟', '𝚓', 'ĵ', 'ǰ', 'Ĵ', 'ȷ', 'ɉ'},
	'k': {'κ', '𝐤', '𝑘', '𝒌', '𝓴', '𝔨', '𝕜', '𝖐', '𝗸', '𝘬', '𝙠', '𝚔', 'ķ', 'ǩ', 'ḱ', 'ḳ', 'ḵ', 'Ķ', 'Ǩ', 'Ḱ', 'Ḳ', 'Ḵ', 'ƙ', 'ɨ'},
	'l': {'ⅼ', 'ӏ', 'Ɩ', 'ʟ', '𝐥', '𝑙', '𝒍', '𝓵', '𝔩', '𝕝', '𝖑', '𝗹', '𝘭', '𝙡', '𝚕', 'ĺ', 'ļ', 'ľ', 'ŀ', 'ł', 'ḷ', 'ḹ', 'ḻ', 'ḽ', 'Ĺ', 'Ļ', 'Ľ', 'Ŀ', 'Ł', 'Ḷ', 'Ḹ', 'Ḻ', 'Ḽ', 'ƚ', 'ȴ'},
	'm': {'м', 'ṃ', 'ᴍ', '𝐦', '𝑚', '𝒎', '𝓶', '𝔪', '𝕞', '𝖒', '𝗺', '𝘮', '𝙢', '𝚖', 'ḿ', 'ṁ', 'ṁ', 'ṃ', 'Ḿ', 'Ṁ', 'Ṃ', 'ɱ'},
	'n': {'ո', 'п', 'ռ', 'ṅ', 'ṇ', 'ṋ', '𝐧', '𝑛', '𝒏', '𝓷', '𝔫', '𝕟', '𝖓', '𝗻', '𝘯', '𝙣', '𝚗', 'ń', 'ņ', 'ň', 'ǹ', 'ṅ', 'ṇ', 'ṉ', 'ṋ', 'Ń', 'Ņ', 'Ň', 'Ǹ', 'Ṅ', 'Ṇ', 'Ṉ', 'Ṋ', 'ƞ', 'ɲ', 'ŋ'},
	'o': {'ο', 'օ', 'ӧ', 'ö', 'ó', 'ò', 'ô', 'õ', 'ō', 'ő', 'ⲟ', '𝐨', '𝑜', '𝓸', '𝔬', '𝕠', '𝖔', '𝗼', '𝘰', '𝙤', '𝚬', 'ŏ', 'ő', 'ơ', 'ǒ', 'ǫ', 'ǭ', 'ǿ', 'ȍ', 'ȏ', 'ȫ', 'ȭ', 'ȯ', 'ȱ', 'ṍ', 'ṏ', 'ṑ', 'ṓ', 'ọ', 'ỏ', 'ố', 'ồ', 'ổ', 'ỗ', 'ộ', 'ớ', 'ờ', 'ở', 'ỡ', 'ợ'},
	'p': {'р', 'ρ', '⍴', '𝐩', '𝑝', '𝒑', '𝓹', '𝔭', '𝕡', '𝖕', '𝗽', '𝘱', '𝙥', '𝚭', 'ṕ', 'ṗ', 'Ṕ', 'Ṗ', 'ƥ', 'ƿ'},
	'q': {'զ', 'ԛ', 'գ', '𝐪', '𝑞', '𝒒', '𝓺', '𝔮', '𝕢', '𝖖', '𝗾', '𝘲', '𝙦', '𝚞', 'ʠ'},
	'r': {'ᴦ', 'г', 'ř', 'ȓ', 'ṛ', 'ⲅ', '𝐫', '𝑟', '𝒓', '𝓻', '𝔯', '𝕣', '𝖗', '𝗿', '𝘳', '𝙧', '𝚛', 'ŕ', 'ŗ', 'ř', 'ȑ', 'ȓ', 'ṙ', 'ṛ', 'ṝ', 'ṟ', 'Ŕ', 'Ŗ', 'Ř', 'Ȑ', 'Ȓ', 'Ṙ', 'Ṛ', 'Ṝ', 'Ṟ', 'ɍ', 'ɽ', 'ɾ', 'ɿ'},
	's': {'ѕ', 'ʂ', 'ṡ', 'ṣ', '𝐬', '𝑠', '𝒔', '𝓼', '𝔰', '𝕤', '𝖘', '𝗌', '𝘴', '𝙨', '𝚜', 'ś', 'ŝ', 'ş', 'š', 'ș', 'ṡ', 'ṣ', 'ṥ', 'ṧ', 'ṩ', 'Ś', 'Ŝ', 'Ş', 'Š', 'Ș', 'Ṡ', 'Ṣ', 'Ṥ', 'Ṧ', 'Ṩ', 'ƨ', 'ʃ'},
	't': {'т', 'τ', 'ṭ', 'ț', 'ⲧ', '𝐭', '𝑡', '𝒕', '𝓽', '𝔱', '𝕥', '𝖙', '𝘵', '𝙩', '𝚝', 'ţ', 'ť', 'ŧ', 'ț', 'ṫ', 'ṭ', 'ṯ', 'ṱ', 'Ţ', 'Ť', 'Ŧ', 'Ț', 'Ṫ', 'Ṭ', 'Ṯ', 'Ṱ', 'ƚ', 'ƭ', 'ʇ'},
	'u': {'υ', 'ս', 'ü', 'ú', 'ù', 'û', 'ū', 'ⲩ', '𝐮', '𝑢', '𝒖', '𝓾', '𝔲', '𝕦', '𝖚', '𝘶', '𝙪', '𝚞', 'ŭ', 'ů', 'ű', 'ų', 'ư', 'ǔ', 'ǖ', 'ǘ', 'ǚ', 'ǜ', 'ȕ', 'ȗ', 'ṳ', 'ṵ', 'ṷ', 'ṹ', 'ṻ', 'ụ', 'ủ', 'ứ', 'ừ', 'ử', 'ữ', 'ự'},
	'v': {'ν', 'ѵ', 'ⴸ', '𝐯', '𝑣', '𝒗', '𝓿', '𝔳', '𝕧', '𝖛', '𝗏', '𝘷', '𝙫', '𝚟', 'ṽ', 'ṿ', 'Ṽ', 'Ṿ', 'ʋ', 'ʌ'},
	'w': {'ԝ', 'ա', 'ѡ', 'ⲱ', '𝐰', '𝑤', '𝒘', '𝔀', '𝔴', '𝕨', '𝖜', '𝗐', '𝘸', '𝙬', '𝚠', 'ŵ', 'ẁ', 'ẃ', 'ẅ', 'ẇ', 'ẉ', 'ẘ', 'Ŵ', 'Ẁ', 'Ẃ', 'Ẅ', 'Ẇ', 'Ẉ', 'ƺ'},
	'x': {'х', 'ҳ', 'ӿ', '𝐱', '𝑥', '𝒙', '𝔁', '𝔵', '𝕩', '𝖝', '𝗑', '𝘹', '𝙭', '𝚡', 'ẋ', 'ẍ', 'Ẋ', 'Ẍ'},
	'y': {'у', 'ү', 'ӯ', 'ý', 'ÿ', 'ⲩ', '𝐲', '𝑦', '𝒚', '𝔂', '𝔶', '𝕪', '𝖞', '𝗒', '𝘺', '𝙮', '𝚢', 'ŷ', 'ȳ', 'ẏ', 'ỳ', 'ỵ', 'ỷ', 'ỹ', 'Ŷ', 'Ý', 'Ÿ', 'Ȳ', 'Ẏ', 'Ỳ', 'Ỵ', 'Ỷ', 'Ỹ', 'ƴ'},
	'z': {'ᴢ', 'ż', 'ź', 'ž', '𝐳', '𝑧', '𝒛', '𝔃', '𝔷', '𝕫', '𝖟', '𝗓', '𝘻', '𝙯', '𝚣', 'ź', 'ż', 'ž', 'ẑ', 'ẓ', 'ẕ', 'Ź', 'Ż', 'Ž', 'Ẑ', 'Ẓ', 'Ẕ', 'ƶ', 'ȥ', 'ɀ'},
}

func usage() {
	fmt.Fprintf(os.Stderr, "usage: %s [-i input] [-v] [-m max]\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "  -i  input (letter or word)\n")
	fmt.Fprintf(os.Stderr, "  -v  verbose (show punycode)\n")
	fmt.Fprintf(os.Stderr, "  -m  max combinations (default 1000)\n")
	fmt.Fprintf(os.Stderr, "reads from stdin if no flags given\n")
}

func toPunycode(s string) string {
	encoded, err := idna.ToASCII(s)
	if err != nil {
		return ""
	}
	return encoded
}

func processInput(input string, maxCombinations int, verbose bool) {
	input = strings.TrimSpace(strings.ToLower(input))
	if len(input) == 0 {
		return
	}
	
	if len(input) == 1 {
		variants := homoglyphs[rune(input[0])]
		for _, v := range variants {
			if verbose {
				if p := toPunycode(string(v)); p != "" {
					fmt.Printf("%c \033[32m→\033[0m %s\n", v, p)
				}
			} else {
				fmt.Printf("%c\n", v)
			}
		}
		return
	}
	
	chars := []rune(input)
	count := 0
	var generate func(int, string)
	generate = func(pos int, current string) {
		if count >= maxCombinations {
			return
		}
		if pos == len(chars) {
			if verbose {
				if p := toPunycode(current); p != "" {
					fmt.Printf("%s → %s\n", current, p)
					count++
				}
			} else {
				fmt.Println(current)
				count++
			}
			return
		}
		
		char := chars[pos]
		generate(pos+1, current+string(char))
		
		if variants := homoglyphs[char]; variants != nil {
			for _, v := range variants {
				generate(pos+1, current+string(v))
			}
		}
	}
	generate(0, "")
}

func main() {
	var input = flag.String("i", "", "")
	var verbose = flag.Bool("v", false, "")
	var maxCombinations = flag.Int("m", 1000, "")
	
	flag.Usage = usage
	flag.Parse()
	
	if *input != "" {
		processInput(*input, *maxCombinations, *verbose)
		return
	}
	
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		processInput(scanner.Text(), *maxCombinations, *verbose)
	}
}
